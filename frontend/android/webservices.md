# Web services

## Basics

jCrystal generates the code required on the frontend to consume the web services of the backend, you can find them as static methods in the jCrystal generated folder: `jcrystal/mobile/net/controllers` on java files that start with the name `Manager`. 

The file names generated by jCrystal match the ones created in the backend, meaning that if your backend developer (or you!) creates a web service named `getUser` on the class `ManagerUser` used by this client, then the code generated on Android will have a class named `ManagerUser.java` with one or many static methods called `getUser` to consume that web service. In this way, jCrystal enhances the communication of a team of developers, and even when there's only one developer in all the platforms, the development is easier since everything is called exactly the same. 

The code to consume a web service is enclosed in a static method whose parameters define:
- The different parameters or the body of the HTTP request.
- The way to manage a successful response of the server and the type of that response (if there is one).
- The way to manage an error when doing the request. 

Therefore, just by looking at the signature of the method to consume a web service, you can know what parameters does it need (if any at all) and what is the expected response of the server.

Specifically, the parameters of a static method to consume a web service are these, in this order:

- A class that extends an Android Activity or Fragment, and that can optionally implement the interface `OnErrorListener`. 

- The parameters of the web service. Each one is a parameter of the static method and has the same name and equivalent type used by the backend developer.

- An `onSuccess` callback that is called when the HTTP request is successful. The callback receives the objects and their types that the backend returns for this web service or void if it doesn't return anything.

- An `onError` callback that is called when the HTTP request fails in any way. If the first parameter implements the interface `OnErrorListener`, then, this parameter is not required. 

## Error management

If you have an activity that calls multiple web services and the error management of those web services is the same (for example, showing a Toast), you can implement `OnErrorListener` on your activity to avoid rewriting the error callback: 

```java
import jcrystal.mobile.net.controllers.ManagerHello;
import jcrystal.mobile.net.utils.OnErrorListener;
import jcrystal.mobile.net.utils.RequestError;

public class MyActivity extends Activity implements OnErrorListener {
...
    ManagerHello.ping(this, resp -> {
      	//On success
    });

	...

	public void onError(RequestError error) {
		//On error
    }
	...
}
```

## Sending and receiving entities
On jCrystal web services can send and receive entities, however, we prioritize always sending or receiving exactly the information that is required on each web service. That's why when a web service sends or receives an entity, the type of the parameter that contains the entity is not the class of the entity in Android, but an interface which is a level of the entity. For example, instead of receiving the type `User`, you will receive something like `UserBasic` or `UserMin`.
 
The level of the entity is an interface that is implemented by the main class, and that has the same name followed by a level. You can find more information on this subject in the [entities section](entities.md).
 
As an example, if an entity `User` has these attributes:
- Name
- Gender
- Birthdate
- Date created
- Last login
- Country
- City
- Favorite color

Let's say that on your frontend you need to list all the users and show the name and last login; then, you don't need to receive all the attributes of the users, so the backend developer might say that the attributes Name and Last Login will comprise the "Minimum" level of the entity `User`; therefore, the interface `UserMin` will contain only those attributes and methods to access and modify them. Additionally, the web service that gives you the list of all users on the frontend will return a list of the interface `UserMin`.

So, how can you work with those interfaces to send them or receive them?  
Usually, when you have to send an interface you can create an instance of the class that implements that interface. Following our previous example, if you need to send something of type `UserMin`, you can do this:
```java
import jcrystal.mobile.entities.User;
import  jcrystal.mobile.entities.UserMin;
...
UserMin userMin = new User();
```
Then, you can set the properties that UserMin has and send the entity to the backend.  
Remember to always **import** both the interface and the main class. 

Additionally, when you are receiving an entity, you can use it directly to access its attributes:

```java
import  jcrystal.mobile.entities.UserMin;
...
    // userMin has the type UserMin
    String name = userMin.name();
```
Or cast it as the main class, like this:

```java
import jcrystal.mobile.entities.User;
import  jcrystal.mobile.entities.UserMin;
...
    // userMin has the type UserMin
    User user = (User)userMin;
```
The first approach is safer because by using the interface, you can only access to the attributes that the backend sent. In contrast, if you cast the object you will be able to access attributes that might not be there. In the last example, the object `user` only has the attributes Name and LastLogin, but you could try to get the attribute `City` that the backend never sent, so you might get an empty or null `City`, which would be an erroneous value because you don't know if on the backend database this attribute is empty since the backend never sent it.  

## Chaining responses

Coming soon :flushed: 

## FAQ

**How do you know if a web service is GET, POST, PUT or DELETE?**

You no longer have to worry about that! :grin: jCrystal was created to help you communicate with the server, therefore the only thing you have to worry about is calling the method to consume the web service and jCrystal will do everything else for you. If you really want to know, you can check the generated code to find out the type of HTTP request for each web service.

**How do you know which services you can access, what are their names, inputs and outpus?**

There are a couple of ways:

- Check the backend or talk with your backend developer. 

    The structure and names of the web services on the backend and the frontend are the same. 

    This means that if on the backend there's web service named `getUser` on the class `ManagerUser.java` and this service is annotated to be used by your client, then on your generated code, you must have a class named `ManagerUser.ts` with a static method named `getUser`.

    Learn more about coding web services on the backend and annotating them to use clients [here](../../server/clients/general.md).

- Check the generated code. 
    
    On the generated code you can find the web services that you can use; specifically, on the folder `jcrystal/services/` inside classes with `Manager` as a prefix, each of the static methods of these classes are webservices that you can consume.

    Learn more about the anatomy of the generated code [here](anatomy.md).

    Additionally, we suggest that you use a code editor that has auto-completion capabilities and helps you check the signature of a method easily.

## Examples
Coming soon :flushed: