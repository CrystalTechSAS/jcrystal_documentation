# Android

## Setup

On your Android project, include the following changes on your root build.gradle:

```gradle
allprojects {
    repositories {
		....
		maven { url 'https://jitpack.io' }
	}
}
```

And the following changes on the module gradle:
```gradle
android {
  ...
  // Configure your module to use Java 8 language features
  compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
  }
}
dependencies {
    ...
    implementation 'com.github.CrystalTechSAS:jCrystalAndroidLib:3ed32e7c0d'
}
```

## Adding the jCrystal generated code to your project
The generated code of jCrystal must be added in the folder: `app/src/main/java` of your Android application. You can copy-paste the generated folder directly on this folder or if you have access to the backend project, you can set the output folder of this client to your the `app/src/main/java` folder of your Android project and generate jCrystal (from the backend). 

## Consuming Services
Call the web services generated by jCrystal in the following way:

```java
import jcrystal.mobile.net.controllers.ManagerHello;
...
    ManagerHello.ping(this, resp -> {
      	//On success
    }, error -> {
		//On error
	});

```

Where `this` can be an `Activity` or `Fragment`. Additionally, remember to import the class of your web service in your activity or fragment. 

If you have an activity that calls multiple web services and the error management of those web services is the same (for example, showing a Toast), you can implement `OnErrorListener` on your activity to avoid rewriting the error callback: 

```java
import jcrystal.mobile.net.controllers.ManagerHello;
import jcrystal.mobile.net.utils.OnErrorListener;
import jcrystal.mobile.net.utils.RequestError;

public class MyActivity extends Activity implements OnErrorListener {
...
    ManagerHello.ping(this, resp -> {
      	//On success
    });

	...

	public void onError(RequestError error) {
		//On error
    }
	...
}
```

How do you know which services you can access, what are their names, inputs and outpus? There are a couple of ways:

- Check the backend or talk with your backend developer. 

    The structure and names of the web services on the backend and the frontend are the same. 

    This means that if on the backend there's web service named `getUser` on the class `ManagerUser.java` and this service is annotated to be used by your client, then on your generated code, you must have a class named `ManagerUser.ts` with a static method named `getUser`.

    Learn more about coding web services on the backend and annotating them to use clients [here](/server/clients/general.md).

- Check the generated code. 
    
    On the generated code you can find the web services that you can use; specifically, on the folder `jcrystal/services/` inside classes with `Manager` as a prefix, each of the static methods of these classes are webservices that you can consume.

    Learn more about the anatomy of the generated code [here](anatomy.md).

    Additionally, we suggest that you use a code editor that has auto-completion capabilities and helps you check the signature of a method easily.

## What's next
After you have set up your Angular client, you are ready to use the generated code. 
Learn more about:
- [The anatomy of the generated folder.](anatomy.md)
- [The web services generated by jCrystal.](webservices.md)
- [The entities generated by jCrystal.](entities.md)
- [The enums generated by jCrystal.](enums.md)