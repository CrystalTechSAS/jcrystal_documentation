# Web services

jCrystal generates the code required on the frontend to consume the web services of the backend, you can find them as static methods in the jCrystal generated folder: `jcrystal/services` on typescript files that start with the name `Manager`. 

The file names generated by jCrystal match the ones created in the backend, meaning that if your backend developer (or you!) creates a web service named `getUser` on the class `ManagerUser` used by this client, then the code generated on Angular will have a class named `ManagerUser.ts` with a static method `getUser` to consume that web service. In this way, jCrystal enhances the communication of a team of developers, and even when there's only one developer in all the platforms, the development is easier since everything is called exactly the same. 

The code to consume a web service is enclosed in a static method whose parameters define:
- The different parameters or the body of the HTTP request.
- The way to manage a successful response of the server and the type of that response (if there is one).
- The way to manage an error when doing the request. 

Therefore, just by looking at the signature of the method to consume a web service, you can know what parameters does it need (if any at all) and what is the expected response of the server.

Specifically, the parameters of a static method to consume a web service are these, in this order:

- A class that implements the interface `NetworkBase`, which basically requires that the class has an attribute called `http` of the type `HttpClient`. This will help jCrystal do the request using the simplified client [HTTP API of Angular](https://angular.io/guide/http).  

    We suggest to include in the constructor of the component that's going to call this method, this: `public http : HttpClient`.

- The parameters of the web service. Each one is a parameter of the static method and has the same name and equivalent type used by the backend developer.

- An `onSuccess` function that is called when the HTTP request is successful. It has this form: `(<return params>) => void`, where `<return params>` are the objects that the backend returns for this web service or void if it doesn't return anything.

- A `onError` function that is called when the HTTP request fails in any way. This parameter has a default value, so you don't have to provide the onError function if you prefer that jCrystal manages the error (it shows an alert with the error).

Let's see the signature of some methods generated by jCrystal to fully grasp the meaning of its parameters and how to use them.

**Web service with no parameters and empty return**

Although web services with no parameters and no returns are unusual, they might be helpful to do an initial setup of the database. 

The signature of the web service:
```typescript
...
export class ManagerTest{
	/**
	* /api/test/doInitialSetup
	**/
	static doInitialSetup(base : NetworkBase,onSuccess: () => void,onError : (error : RequestError)=>void = defaultOnError){
        ...
    }
    ...
}
```
As you can see, after the parameter `NetworkBase` there are no other parameters; also, the `onSuccess` is a function of type `() => void`, meaning that this web service doesn't return anything. Also, remember that this class is **generated** by jCrystal, so you only need to check it out to know how to use the web service. 

Take into account that the fact that the service doesn't return anything doesn't mean that you don't know if the service executed correctly or not. If there was an error on the execution of the request, the function `onError` is called an the function `onSuccess` is never called. 

The code to consume the web service is this:
```typescript
...
import { ManagerTest } from './jcrystal/services/ManagerTest';
import { HttpClient } from '@angular/common/http';
export class MyComponent {
	constructor(public http: HttpClient) { }
...
    ManagerTest.doInitialSetup(this, () => {
        //On success
    }, error => {
        //On error
    });
...
}
```

Take into account that on your component constructor you must add `public http : HttpClient`. Also remember to import the class of your web service in your component.

**Web service with no parameters that returns a String**

Now, let's see how a simple ping that expects an answer from the backend looks like; the signature of the generated web service is this:
```typescript
...
export class ManagerTest{
	/**
	* /api/test/ping
	**/
	static ping(base : NetworkBase,onSuccess: (r:string)=> void ,onError : (error : RequestError)=>void = defaultOnError){
        ...
    }
    ...
}
```
As you can see, after the parameter `NetworkBase` there are no other parameters; also, the `onSuccess` is a function of type `(r:string) => void`, meaning that this web service returns a string. 

The code to consume the web service is this:
```typescript
...
import { ManagerTest } from './jcrystal/services/ManagerTest';
import { HttpClient } from '@angular/common/http';
export class MyComponent {
	constructor(public http: HttpClient) { }
...
    ManagerTest.ping(this, () => {
        //On success
    }, error => {
        //On error
    });
...
}
```

Take into account that on your component constructor you must add `public http : HttpClient`. Also remember to import the class of your web service in your component.



**Web service with one parameters and empty return**

A web service with one parameter, that doesn't return anything:

**Web service with three parameters and returns an Entity**

A web service with two parameters, that returns a string and an int:

**Web service with one  parameters and multiple returns**

A web service with two parameters, that returns an entity User: