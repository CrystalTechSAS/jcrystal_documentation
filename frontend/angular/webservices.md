# Web services

## Basics

jCrystal generates the code required on the frontend to consume the web services of the backend, you can find them as static methods in the jCrystal generated folder: `jcrystal/services` on typescript files that start with the name `Manager`. 

The file names generated by jCrystal match the ones created in the backend, meaning that if your backend developer (or you!) creates a web service named `getUser` on the class `ManagerUser` used by this client, then the code generated on Angular will have a class named `ManagerUser.ts` with a static method `getUser` to consume that web service. In this way, jCrystal enhances the communication of a team of developers, and even when there's only one developer in all the platforms, the development is easier since everything is called exactly the same. 

The code to consume a web service is enclosed in a static method whose parameters define:
- The different parameters or the body of the HTTP request.
- The way to manage a successful response of the server and the type of that response (if there is one).
- The way to manage an error when doing the request. 

Therefore, just by looking at the signature of the method to consume a web service, you can know what parameters does it need (if any at all) and what is the expected response of the server.

Specifically, the parameters of a static method to consume a web service are these, in this order:

- A class that implements the interface `NetworkBase`, which basically requires that the class has an attribute called `http` of the type `HttpClient`. This will help jCrystal do the request using the simplified client [HTTP API of Angular](https://angular.io/guide/http).  

    We suggest to include in the constructor of the component that's going to call this method, this: `public http : HttpClient`.

- The parameters of the web service. Each one is a parameter of the static method and has the same name and equivalent type used by the backend developer.

- An `onSuccess` function that is called when the HTTP request is successful. It has this form: `(<return params>) => void`, where `<return params>` are the objects and their types that the backend returns for this web service or void if it doesn't return anything.

- A `onError` function that is called when the HTTP request fails in any way. This parameter has a **default value**, so you don't have to provide the onError function if you prefer that jCrystal manages the error (it shows an alert with the error).

## Error management

jCrystal can manage the error handling by showing an alert with the error message if a web service returns an error. Therefore, if you want jCrystal to manage errors, you don't have to implement the error callback. 

As an example, if you have a `ping` method of a class generated with jCrystal, you can implement the onSuccess function and not the onError.

```typescript
...
import { ManagerHello } from './jcrystal/services/ManagerHello';
import { HttpClient } from '@angular/common/http';
export class MyComponent {
	constructor(public http: HttpClient) { }
...
    ManagerHello.ping(this, resp => {
        //On success
    });
}
```

If you do this how do you know when an error with a request happens?

## Sending and receiving entities
On jCrystal web services can send and receive entities, however, we prioritize always sending or receiving exactly the information that is required on each web service. That's why when a web service sends or receives an entity, the type of the parameter that contains the entity is not the class of the entity in typescript, but an interface which is a level of the entity. For example, instead of receiving the type   `User`, you will receive something like `UserBasic` or `UserMin`.
 
The level of the entity is an interface that is implemented by the main class, and that has the same name followed by a level. You can find more information on this subject in the entities section. 
 
As an example, if an entity `User` has these attributes:
- Name
- Gender
- Birthdate
- Date created
- Last login
- Country
- City
- Favorite color

Let's say that on your frontend you need to list all the users and show the name and last login; then, you don't need to receive all the attributes of the users, so the backend developer might say that the attributes Name and Last Login will comprise the "Minimum" level of the entity `User`; therefore, the interface `UserMin` will contain only those attributes and methods to access and modify them. Additionally, the web service that gives you the list of all users on the frontend will return a list of the interface `UserMin`.

So how can you work with those interfaces to send them or receive them?  
Usually, when you have to send an interface you can create an instance of the class that implements that interface. Following our previous example, if you need to send something of type `UserMin`, you can do this:
```typescript
import { UserMin } from './jcrystal/entities/UserMin';
import { User } from './jcrystal/entities/User';
...
    let user: UserMin = new User();
```
Then, you can set the properties that UserMin has and send the entity to the backend.  
Remember to always **import** both the interface and the main class. 

Additionally, when you are receiving an entity, you can use it directly to access its attributes:

```typescript
import { UserMin } from './jcrystal/entities/UserMin';
...
    // userMin has the type UserMin
    let name = userMin.getName();
```
Or cast it as the main class, like this:

```typescript
import { UserMin } from './jcrystal/entities/UserMin';
import { User } from './jcrystal/entities/User';
...
    // userMin has the type UserMin
    let user: User = userMin as User;
```
The first approach is safer because by using the interface, you can only access to the attributes that the backend sent. In contrast, if you cast the object you will be able to access attributes that might not be there. In the last example, the object `user` only has the attributes Name and LastLogin, but you could try to get the attribute `City` that the backend never sent, so you might get an empty or null `City`, which would be an erroneous value because you don't know if on the backend database this attribute is empty since the backend never sent it.  

## Examples
Let's see the signature and usage of some methods generated by jCrystal to fully grasp the meaning of its parameters and how to use them.

**Web service with no parameters and empty return**

Although web services with no parameters and no returns are unusual, they might be helpful to do an initial setup of the database. 

The signature of the web service:
```typescript
...
export class ManagerTest{
	/**
	* /api/test/doInitialSetup
	**/
	static doInitialSetup(base : NetworkBase,onSuccess: () => void,onError : (error : RequestError)=>void = defaultOnError){
        ...
    }
    ...
}
```
As you can see, after the parameter `NetworkBase` there are no other parameters; also, the `onSuccess` is a function of type `() => void`, meaning that this web service doesn't return anything. Also, remember that this class is **generated** by jCrystal, so you only need to check it out to know how to use the web service. 

Take into account that the fact that the service doesn't return anything doesn't mean that you don't know if the service executed correctly or not. If there was an error on the execution of the request, the function `onError` is called an the function `onSuccess` is never called. 

The code to consume the web service is this:
```typescript
...
import { ManagerTest } from './jcrystal/services/ManagerTest';
import { HttpClient } from '@angular/common/http';
export class MyComponent {
	constructor(public http: HttpClient) { }
...
    ManagerTest.doInitialSetup(this, () => {
        //On success
    }, error => {
        //On error
    });
...
}
```

Additionally, don't forget to add `public http : HttpClient` on your component constructor. Also remember to import the class of your web service in your component.

**Web service with no parameters that returns a String**

Now, let's see how a simple ping that receives an answer from the backend looks like; the signature of the generated web service is this:
```typescript
...
export class ManagerTest{
	/**
	* /api/test/ping
	**/
	static ping(base : NetworkBase,onSuccess: (r:string)=> void ,onError : (error : RequestError)=>void = defaultOnError){
        ...
    }
    ...
}
```
As you can see, after the parameter `NetworkBase` there are no other parameters; also, the `onSuccess` is a function of type `(r:string) => void`, meaning that this web service returns a string. 

The code to consume the web service is this:
```typescript
...
import { ManagerTest } from './jcrystal/services/ManagerTest';
import { HttpClient } from '@angular/common/http';
export class MyComponent {
	constructor(public http: HttpClient) { }
...
    ManagerTest.ping(this, resp => {
        //On success
    }, error => {
        //On error
    });
...
}
```

Additionally, don't forget to add `public http : HttpClient` on your component constructor. Also remember to import the class of your web service in your component.

**Web service with one parameters and empty return**

Now, let's see how a service that sends emails from an email address looks like; the signature of the generated web service is this:

```typescript
...
export class ManagerTest{
	/**
	* /api/test/sendMail
	**/
	static sendMail(base : NetworkBase,email:string,onSuccess: () => void,onError : (error : RequestError)=>void = defaultOnError){
        ...
    }
    ...
}
```

As you can see, after the parameter `NetworkBase` there is a string parameter named email; also, the `onSuccess` is a function of type `() => void`, meaning that this web service doesn't return anything.

The code to consume the web service is this:

```typescript
...
import { ManagerTest } from './jcrystal/services/ManagerTest';
import { HttpClient } from '@angular/common/http';
export class MyComponent {
	constructor(public http: HttpClient) { }
...
    ManagerTest.sendMail(this, "myemail@test.com", () => {
        console.log("Email sent");
        //On success
    }, error => {
        //On error
    });
...
}
```
Additionally, don't forget to add `public http : HttpClient` on your component constructor. Also remember to import the class of your web service in your component.

**Web service with two parameters and returns an Entity** 

A service that receives the user name and email and returns the entity created on the backend can have this signature:

```typescript
...
export class ManagerTest{
	/**
	* /api/test/createUser
	**/
    static createUser(base : NetworkBase,name:string,email:string,onSuccess: (r:UserNormal)=> void ,onError : (error : RequestError)=>void = defaultOnError){
            ...
    }
    ...
```

As you can see, after the parameter `NetworkBase` there is a string parameter named `name` and `email`; also, the `onSuccess` is a function of type `(r:UserNormal) => void`, meaning that this web service returns an entity User with access level normal.

```typescript
...
import { ManagerTest } from './jcrystal/services/ManagerTest';
import { HttpClient } from '@angular/common/http';
export class MyComponent {
	constructor(public http: HttpClient) { }
...
    ManagerTest.createUser(this, "John Doe", "john@test.com",  (user) => {
        //On success
    }, error => {
        //On error
    });
...
}
```
Don't forget to add `public http : HttpClient` on your component constructor. Also remember to import the class of your web service in your component.

**Web service with one parameter and multiple returns**
A service that receives the user name and email and returns the entity created on the backend can have this signature:

	static getAllArticlesUsers(base : NetworkBase,name:string,onSuccess: (p0:UserNormal[], p1:ArticleNormal[]) => void,onError : (error : RequestError)=>void = defaultOnError){


ManagerDemo.getAllArticlesUsers(this, "nu", (users, articles) => {

    });


En los últimos años frameworks hechos en lenguajes de programación como Python y Ruby, han logrado lle
En los últimos años fram hechos en lenguajes de programación como ruby, han logrado llevarse el protagonismo en el mercado debido a ideas novedosas que han implementado en los procesos de desarrollo.
 Estos frameworks fueron populares, hubo unas ideas novedosas y apesar de que han habido intentos de llevar a Java esas ideas, queda la sensasi´ón de que la gente prefiere en algunas situacioens las ganancias de esas ideas que producen en otros lenguajes, las ideas que utlizan esos fm en otros lenguajes en contraposición a la manetenbilidad y al deseme



jCrystal es un paso en la dirección de llevar a Java la simplesa y las buenas ideas de estos frameworks de programación de otras leguajes y de llvarlos más alla aprovechando las características superiores de Java como elnguaje