# Entities

A jCrystal entity is a Java class whose objects can be stored on a database. An entity has:

- A unique key.
- A set of fields.
- A set of relations to other entities.

Right now jCrystal supports the storage of your entities on Google Cloud Datastore. However, we are working to support more databases. 

This is a simple entity with a single autogenerated key and a field name:

```java
package company.example.data;

@jcrystal.reflection.annotations.jEntity
public class User {//This entity has an autogenerated key
	
	@jcrystal.reflection.annotations.EntityProperty
	private static String name;

}
```

## Entity keys

A key is a unique combination of values that allows to access a especific entity. jCrystal supports single and compund entity keys:

### Single entity keys

A private static attribute annotated with `@jcrystal.reflection.annotations.EntityKey`. A key can have one of the following types:

| Type     | Description  |
| ------------- |------------------|
| Autogenerated | An automatically assigned long uniquely generated by DB engine |
| Long     | A manually assigned long key |
| long     | A manually assigned long key |
| String     | A manually assigned string key |

You can ommit an entity key and jCrystal will automatically add an Autogenerated id key.

```java
@jcrystal.reflection.annotations.EntityKey
private static Autogenerated id; //Generally speaking, this is not neccessary
```

\*We suggest to declare each key as `private` to avoid confussions.	

### Compound entity keys

We are working on this. :flushed:

## Entity fields

An entity field is a **private static** attribute annotated with `@jcrystal.reflection.annotations.EntityProperty`. At present, jCrystal supports the following types for entity fields:

- Java primitive types and wrapped primitive types.
- Java primitive and wrapped primitive single dimension arrays (eg long[]).
- String.
- [Email class from the datastore.](https://cloud.google.com/appengine/docs/standard/java/javadoc/com/google/appengine/api/datastore/Email)
- [GeoPt class from the datastore.](https://cloud.google.com/appengine/docs/standard/java/javadoc/com/google/appengine/api/datastore/GeoPt)
- [CrystalDates*.](utils/crystal_dates.md)
- [Text.](https://cloud.google.com/appengine/docs/standard/java/javadoc/com/google/appengine/api/datastore/Text)
- Password.
- Autogenerated. 
- FirebaseAccount. 
- [Enums](enums.md)

After you define an entity property and run the jCrystal generator with  `CTRL + 6` (Windows) or `CMD + 6` (Mac OS), jCrystal will generate the _get_ and _set_ methods for each entity field. 

In order **to require a field on the constructor** of the entity, the entity field must be declared with the final word **final**. 


The annotation `@jcrystal.reflection.annotations.EntityProperty` has these parameters:
- _name_ (String): the name that will be internally used in the Datastore table. If you don't set this value, then the name of the field will be used.
- _index_ (IndexType): Defines the type of index applied on this field. Can take the following values:
	- NONE: No index applies to this field
	- MULTIPLE: The most simple type of index. The field is indexed and a query over a value this field can retrieve multiple entities.
	- UNIQUE: The field is indexed and a query over a value this field shoud retrieve only one entity. You must ensure each field value only has one entity.
	- UNIQUE_VERIFICATION: Like UNIQUE but jCrystal will valide the uniqueness and throw an exception if the validation failed.
- _editable_: If set to false, this property will never be modified by a post update. 
- _json_(JsonLevel): The level of access of the entity field. If not set, the default level of an entity property is `JsonLevel.NORMAL`. [Learn more](utils/access_levels).
- _autoNow_ (boolean): This attribute is only allowed on entity fields of type CrystalDate*, it indicates if this field will be automatically initialized with the time of the creation of the entity. 

\*We suggest to declare each field as `private` to avoid confussions.

## Entity relationships

Relationships are fields in an entity that associate them with another entity. A relationship can be one of these types: 'one-to-one', 'many-to-one' or 'many-to-many' and is denoted with a corresponding annotation:

- `@Rel1to1`: Represents a one to one relationship. 
- `@RelMto1`: Represents a many to one relationship.
- `@RelMtoM`: Represents a many to many relationships

Note: All of these annotations are inside the package `jcrystal.reflection.annotations.entities`.

All the relationship annotations have these parameters:
- _target_(String): the name of the pseudo-field that will be created in the referred entity with the inverse relation.
- _keyLevel_(JsonLevel): The level of access of the entity field. There is no default level for a relationship field. [Learn more](utils/access_levels).

The annotations `@Rel1to1` and `@RelMto1` have this additional parameter:
- _name_(String): the name that will be internally used in the Datastore table. If you don't set this value, then the name of the field will be used.

Additionally, the annotation `@RelMtoM` has these additional parameters:
- _small_(boolean): indicates whether the size of this side of the relationship is small.
- _value_(String): the name that will be internally used in the Datastore table. This value must be set. 

Relationship fields are automatically indexed and therefore do not have the _index_ option.

# Using entites on WSs

```java
@JsonMin(value = {Project.class})
@JsonFull(value = {ProjectKey.class})
public static Tupla2<List<Project>, List<ProjectKey>> A(Project.Post.Basic asd, ProjectKey.Post.Min qwe){
	return null;
}
```

# [jCrystal queries](queries.md)



##### Índices complejos
`@Index`

### Pseudoentidades
`@Jsonify`

## Especificación
-TODO- Parámetros.




## Métodos
Tras la primera ejecución de JCrystal se pueden implementar métodos auxiliares que no serán modificados por JCrystal.

### Métodos de inicialización @jcrystal.reflection.annotations.entities.OnConstruct
Los métodos anotados con `@OnConstruct` son llamados desde el constructor del objeto y se usan comúnmente para inicializar el valor de las propiedades.

### Representación como cadena de texto toString
Cuando se usa el nivel de acceso JsonLevel.TOSTRING, el objeto resultante solo contiene el resultado de su método toString y su identificador.

### Métodos generados

#### Constructor
El constructor incluye los parámetros que hayan sido marcados como obligatorios (con _final_) en la declaración de la entidad.  Y cambien a los métodos con la anotación @OnConstruct

Un ejemplo:

#### Setters y getters

## Funciones de consulta
Subclase Query
### Subclase query

## Objetos DAO, según niveles de acceso.



### Nota sobre la generación del código
Una parte del código que genera JCrystal para la entidad se crea dentro del mismo archivo de clase que contiene la definición.

Este código generado se coloca dentro de unos comentarios que delimitan la sección generada, para que en ejecuciones posteriores del generador de código se sobrescriba solo la región generada.

Un ejemplo:
```java
@jcrystal.reflection.annotations.jEntity
public class Room {
  //Aqui se encuentra la especificación.
/* GEN */
 //Aqui se encuentra el codigó generado.
/* END */
}
```

# Advanced topics

Otras anotaciones que puede tener una entidad `@jEntity` son `@CarbonCopy`

@MaxValidation
@MinValidation
Pregunta: valor por defecto?

indexAsProperty Poder hacer consultas.

## Examples