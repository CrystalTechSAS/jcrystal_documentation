# jCrystal entities

A jCrystal entity is a Class which objects can be stored on a database. An entity have:

- A unique key
- A set of fields
- A set of relations to other entities

With jCrystal (beta) you can store your entities on Google Cloud Datastore.

This is a simple entity with a single autogenerated key and a field name:

```java
package company.example.data;

@jcrystal.reflection.annotations.jEntity
public class User {//This entity has an autogenerated key
	
	@jcrystal.reflection.annotations.EntityProperty
	private static String name;

}
```

## Entity keys

A key is a unique combination of values that allows to access a especific entity. jCrystal supports single and compund entity keys:

### Single entity keys

A private static attribute annotated with `@jcrystal.reflection.annotations.EntityKey`. A key can have one of the following types:

| Type     | Description  |
| ------------- |------------------|
| Autogenerated | An automatically assigned long uniquely generated by DB engine |
| Long     | A manually assigned long key |
| long     | A manually assigned long key |
| String     | A manually assigned string key |

You can ommit an entity key and jCrystal will automatically add an Autogenerated id key.

```java
@jcrystal.reflection.annotations.EntityKey
private static Autogenerated id; //Generally speaking, this is not neccessary
```

\*We suggest to declare each key as `private` to avoid confussions.	

### Compound entity keys

We are working on this.

## Entity fields

An entity field is an private static attribute annotated with `@jcrystal.reflection.annotations.EntityProperty`. Actually jCrystal supports the following types for fields:

- Java primitive types and wrapped primitive types
- Java primitive and wrapped primitive single dimension arrays (eg long[])
- String
- Email -TODO- Clase exacta
- GeoPt De Google
- los _wrapper_ de JCrystal para las fechas (CrystalDate).
- [Enums](enums.md)

Entre los métodos que genera JCrystal para los campos están los _getters_ y los _setters_ de cada uno de los campos.

Para que un campo sea __requerido en el constructor__, su especificación debe especificar con la palabra clave _final_.

La anotación `@jcrystal.reflection.annotations.EntityProperty` tiene los siguientes parámetros.
- _name_ (String): nombre interno que se usara para el campo el la tabla del Datastore.
- _index_ (IndexType): Defines the type of index applied on this field. Can take the following values:
	- NONE: No index applies to this field
	- MULTIPLE: The most simple type of index. The field is indexed and a query over a value this field can retrieve multiple entities.
	- UNIQUE: The field is indexed and a query over a value this field shoud retrieve only one entity. You must ensure each field value only has one entity.
	- UNIQUE_VERIFICATION: Like UNIQUE but jCrystal will valide the uniqueness and throw an exception if the validation failed.
- _editable_
- _json_
- _autoNow_ (booleano): aplicable solo a los parámetros de tipos CrystalDate*, indica si estos se inicializan automáticamente con el tiempo actual.

\*We suggest to declare each field as `private` to avoid confussions.

### Niveles de acceso
Los campos de una entidad pueden tener niveles de detalle que especifican subconjuntos de campos con los que se puede presentar el objeto.  Un nivel de detalle incluye  todos los niveles inferiores, p.e: si se pide un objeto con nivel de detalle NORMAL, este incluirá también los campos con nivel MIN y BASIC.

Estos son los niveles posibles en **orden**, especificados en el _enum_ `jcrystal.json.JsonLevel`; a saber:
- MIN
- BASIC
- NORMAL: el nivel de acceso por defecto
- DETAIL
- FULL
Además hay tres niveles especiales.
- NONE: Indica que el campo no se debe incluir en ninguna presentación del objeto.
- ID: solo el identificador.
- TOSTRING: el identificador y el resultado del método `toString()` de la entidad.
- DEFAULT: **No debe usarse**, lo usa JCrystal internamente.

En el caso de las propiedades el nombre del parámetro es _json_, en el de las relaciones _keyLevel_.

_Nota:_ estos niveles de acceso se usan de manera paralela en los servicios.

## Entity relationships

Las relaciones son campos de una entidad que la asocian con otra, pueden ser '1 a 1', 'muchos a muchos' o 'muchos a 1', estos campos se denotan con las siguientes anotaciones [todas del paquete `jcrystal.reflection.annotations.entities`]:
- `@Rel1to1`
- `@RelMto1`
- `@RelMtoM`

Todas comparten los mismos parámetros:
- _name_(String): equivalente al parámetro del mismo nombre en las propiedades
- _target_(String): nombre del pseudo-campo que se creara en la entidad referida con la relación inversa.
- _keyLevel_: equivalente al parámetro _json_ en las propiedades
- _editable_(boolean): equivalente al parámetro del mismo nombre en las propiedades

Los campos de relación, son indexados automáticamente y por tanto no tienen la opción _indexed_.

Los campos de relación no tienen nivel por defecto.

# [Using entites on WSs](webservices_entities.md)

# [jCrystal queries](queries.md)

##### Niveles de detalle



##### Índices complejos
`@Index`

### Pseudoentidades
`@Jsonify`

## Especificación
-TODO- Parámetros.




## Métodos
Tras la primera ejecución de JCrystal se pueden implementar métodos auxiliares que no serán modificados por JCrystal.

### Métodos de inicialización @jcrystal.reflection.annotations.entities.OnConstruct
Los métodos anotados con `@OnConstruct` son llamados desde el constructor del objeto y se usan comúnmente para inicializar el valor de las propiedades.

### Representación como cadena de texto toString
Cuando se usa el nivel de acceso JsonLevel.TOSTRING, el objeto resultante solo contiene el resultado de su método toString y su identificador.

### Métodos generados

#### Constructor
El constructor incluye los parámetros que hayan sido marcados como obligatorios (con _final_) en la declaración de la entidad.  Y cambien a los métodos con la anotación @OnConstruct

Un ejemplo:

#### Setters y getters

## Funciones de consulta
Subclase Query
### Subclase query

## Objetos DAO, según niveles de acceso.



### Nota sobre la generación del código
Una parte del código que genera JCrystal para la entidad se crea dentro del mismo archivo de clase que contiene la definición.

Este código generado se coloca dentro de unos comentarios que delimitan la sección generada, para que en ejecuciones posteriores del generador de código se sobrescriba solo la región generada.

Un ejemplo:
```java
@jcrystal.reflection.annotations.jEntity
public class Room {
  //Aqui se encuentra la especificación.
/* GEN */
 //Aqui se encuentra el codigó generado.
/* END */
}
```

# Advanced topics

Otras anotaciones que puede tener una entidad `@jEntity` son `@CarbonCopy`

